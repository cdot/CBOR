/* eslint-env node, mocha */

if (typeof requirejs === "undefined") {
  requirejs = require("requirejs");
  requirejs.config({ baseUrl: `${__dirname}/..` });
}

describe("TypeMap", () => {

  let assert,
      Encoder,
      Decoder,
      MemoryInStream,
      MemoryOutStream,
      TypeMapMixin,
      KeyDictionaryMixin,
      IDREFMixin,
      TagHandler;

  function UNit() {}

  before(required => {
    requirejs([
      "chai",
      "js/Encoder",
      "js/Decoder",
      "js/MemoryInStream",
      "js/MemoryOutStream",
      "js/TypeMapMixin",
      "js/KeyDictionaryMixin",
      "js/IDREFMixin",
      "js/TagHandler" ], function () {
        const args = [...arguments];
        assert = args.shift().assert;
        Encoder = args.shift();
        Decoder = args.shift();
        MemoryInStream = args.shift(),
        MemoryOutStream = args.shift();
        TypeMapMixin = args.shift();
        KeyDictionaryMixin = args.shift();
        IDREFMixin = args.shift();
        TagHandler = args.shift();
        required();
      });
  });

  class Wibble {
    strap = "original";
    strop() { return "blah"; }
  }

  function makeTagger(A, B, C) {
    const tagger = new (A(B(C(TagHandler))))({
      typeMap: { Wibble: Wibble }
    });

    // TypeMap
    {
      let frood = new Wibble('frood1');
      frood.strap = "modified";
      let simple = {
        obj1: frood,
        obj2: frood,
        obj3: new Wibble('not frood')
      };
      const outs = new MemoryOutStream();
      const encoder = new Encoder(outs, tagger);
      encoder.encode(simple);
      const frozen = outs.Uint8Array;
      const decoder = new Decoder(new MemoryInStream(frozen), tagger);
      const thawed = decoder.decode();
      assert(thawed.obj1 instanceof Wibble);
      assert(thawed.obj2 instanceof Wibble);
      assert(thawed.obj3 instanceof Wibble);
      assert.deepEqual(thawed, simple);
    }

    // KeyDictionary
    {
      const ABC = {
        Aardvaark: "a", Budgerigar: "b", Crocodile: "c"
      };
      const outs = new MemoryOutStream();
      const encoder = new Encoder(outs, tagger);
      //encoder.debug = console.debug;
      encoder.encode(ABC);
      const frozen = outs.Uint8Array;
      const decoder = new Decoder(new MemoryInStream(frozen), tagger);
      const thawed = decoder.decode();
      assert.deepEqual(thawed, ABC);
    }

    // IDREF
    {
      let frood = {
        blah: "blah"
      };
      frood.selfRef = frood;

      const outs = new MemoryOutStream();
      new Encoder(outs, tagger).encode(frood);
      const frozen = outs.Uint8Array;
      const decoder = new Decoder(new MemoryInStream(frozen), tagger);
      const thawed = decoder.decode();
      assert(thawed.selfRef === thawed);
    }
  }

  it("KeyDictionaryMixin, IDREFMixin, TypeMapMixin", () => {
    makeTagger(KeyDictionaryMixin, IDREFMixin, TypeMapMixin);
  });

  it("IDREFMixin, KeyDictionaryMixin, TypeMapMixin", () => {
    makeTagger(IDREFMixin, KeyDictionaryMixin, TypeMapMixin);
  });
  
  it("IDREFMixin, TypeMapMixin, KeyDictionaryMixin", () => {
    makeTagger(IDREFMixin, TypeMapMixin, KeyDictionaryMixin);
  });
});
         
