/*Copyright (C) 2022 Crawford Currie http://c-dot.co.uk*/

/**
 * Base class for tag handler objects passed to CBOR for encode/decode.
 * During encoding, the tagger `encode()` method is called on every
 * key-value object. The tagger function can decide whether to generate
 * a tag to indicate special semantics for the object, or even replace
 * it completely.
 *
 * See the CBOR specification for information about tagging.
 *
 * The CBOR directory contains a number of mixins that enhance the
 * functionality here with support for different tags.
 */
class TagHandler {

  constructor(options) {
    this.options = options || {};
  }

  /**
   * If the object needs to be tagged, implementations will call
   * {@linkcode Encoder.writeTag} which will inject a tag into
   * the encoded data stream. The tag can be followed with calls to
   * {@linkcode Encoder.encodeItem} though care must be taken not
   * to cause an infinite loop by calling it on `value`.
   * If the value is not tagged, or you want to apply standard CBOR
   * encoding to the object, then return the object. Otherwise if the
   * object is fully encoded by the tagger, return undefined.
   * @param {object} value object that may need to be tagged
   * @param {Encoder} cbor the encoder that is doing the encoding.
   * @return {object} object that needs to be serialised after this
   * tag has been processed, or undefined if sufficient has been
   * written by the tag handler to fully encode the value.
   */
  encode(value, cbor) { return value; }

  /**
   * Decode a tag. The decoding of the tag and it's data must exactly
   * mirror the encoding.
   * @param {number} tag the tag ID.
   * @param {Decoder} cbor the decoder invoking the tagger.
   * @return {object?} return the thawed object, or undefined if the
   * tag was not handled by the tag handler.
   */
  decode(tag, cbor) { return undefined; }

  /**
   * Called by {@linkcode Encoder} at the start of encoding.
   * @param {Encoder} encoder the encoder
   */
  startEncoding(encoder) {}

  /**
   * Called by {@linkcode Encoder} at the end of encoding.
   * @param {Encoder} encoder the encoder
   */
  finishEncoding(encoder) {}

  /**
   * Called by {@linkcode Decoder} at the end of decoding.
   * @param {Decoder} decoder the decoder
   * @param {object} data the decoded data
   */
  finishDecoding(encoder, data) {}

  /**
   * When reading from a stream, there may be tags that apply to
   * the object that follows. So we make the tag handler
   * responsibile for creating arrays.
   * @param {Decoder} decoder the calling decoder
   * @return {Array} a new array
   */
  createArray(decoder) { return []; }

  /**
   * When reading from a stream, there may be tags that apply to
   * the object that follows. So we make the tag handler
   * responsibile for creating basic objects.
   * @param {Decoder} decoder the calling decoder
   * @param {object?} proto the prototype of the new object
   * @return {object} a new simple object
   */
  createObject(decoder, proto) {
    return proto ? Object.create(proto) : {};
  }

  /**
   * Optionally map a key to a more compact representation. Implementations
   * must call superclass and abort if it returns undefined.
   * @param {string} key the key to encode
   * @param {Encoder} encoder the encoder
   * @return {object} a unique identifier for the key, or `undefined` if
   * you want the key to be skipped. By default, the base class will skip
   * all keys that start with '_' to avoid encoding temporary objects.
   */
  encodeKey(key, encoder) {
    if (/^_/.test(key))
      return undefined;
    return key;
  }

  /**
   * Map a compact key representation to the full key. Note that
   * superclass may not be invoked.
   * @param {object} id key identifier, as generated by `encodeKey`
   * @param {Decoder} decoder the calling decoder
   * @return {string} the actual key
   */
  decodeKey(id, decoder) { return id; }
}

export { TagHandler }
